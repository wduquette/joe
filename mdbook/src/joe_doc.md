# joe doc

The `joe doc` processor is used to extract JoeDoc documentation comments
from `.java` and `.joe` source files, and from them generate Markdown 
API documentation.[^markdown] 

The [API sections](library.md) of this user's guide were generated by
`joe doc`.

- [Documentation Set](#joedoc-structure)
  - [Documentation Comments](#documentation-comments)
  - [Entity Tags](#entity-tags)
  - [Example](#example)
- [Entity Types](#entity-types)
  - [The `@package` Entity](#the-package-entity)
  - [The `@function` Entity](#the-function-entity)
  - [The `@type` Entity](#the-type-entity)
  - [The `@constant` Entity](#the-constant-entity)
  - [The `@static` Entity](#the-static-entity)
  - [The `@init` Entity](#the-init-entity)
  - [The `@method` Entity](#the-method-entity)
- [JoeDoc Links](#joedoc-links)
  - [Qualified Type Names](#qualified-type-names)
  - [Entity Mnemonics](#entity-mnemonics)
- [Running `joe doc`](#running-joe-doc)
  - [Configuring `joe doc`](#configuring-joe-doc)
  - [Generated Files](#generated-files)

## Documentation Set

A *documentation set* is the generated JoeDoc documentation for the
packages in the current project.  It will include documentation for the
following types of entity:

- Packages
  - Functions
  - Types
    - Constants
    - Static Methods
    - Initializers
    - Methods

Unsurprisingly, this is the same structure you'll find in the 
[Extending Joe](extending/extending.md) section.  And unsurprisingly,
the generated documentation has this same structure.

### Documentation Comments

A documentation comment is a block of comments beginning with the following
marker comment: `//**` and continuing through contiguous comment lines until
the next non-comment line:

```java
// Not in a doc comment

//**
// @package my.package
//
// Information about `my.package` in Markdown format.
// ...

// Not in a doc comment
```

The comment prefix `//` must be the first non-whitespace text on each line.

`joe doc` extracts all doc comment lines from a source file, removes the 
comment prefixes, and then parses them to extract the documentation 
according to its structure.

### Entity Tags

In the example just shown, the tag `@package` indicates that the following 
comment text concerns the named package.  `joe doc` understands the following
entity tags:

- `@package <name>`
  - `@function <name>`
  - `@type <name>`
    - `@constant <name>`
    - `@static <name>`
    - `@init`
    - `@method <name>`

This is the same outline [shown above](#joedoc-structure), and purposely so.

- `@package` must be the first entity tag in a given file.
- The `@function` and `@type` entities that follow are added to that package.
- The `@constant`, `@static`, `@init`, and `@method` entities that follow a
  `@type` are added to that type.

`joe doc` checks carefully for duplicates.

- Each `@function` and `@type` must be unique in the `@package`.
- Each `@constant`, `@static`, and `@method` must be unique in the `@type`.
- A `@type` can have at most a single `@init` (initializer) entity; and it 
  has no name because it always has the same name as its type.

Packages are special; a single Joe package's code is often spread across 
a number of files. Thus, the same `@package` name can appear in multiple
files, and the related entities will all be ascribed to the same package.

A single source file may (in principle) contain documentation for multiple
packages and types.  If `joe doc` sees a second `@package`, it immediately
switches to that `@package`, and so for the others.

### Example

Here is the beginning of the documentation in Joe's `StandardLibrary.java`
file:

```java
//**
// @package joe
// @title Joe Standard Library
// The `joe` package contains Joe's standard library.

... java code ...

//**
// @function catch
// @args callable
// @result Pair
// Executes the callable, which must not require any arguments.
// Returns `Pair(#ok, returnValue)` on success and
// `Pair(#error, Error)` on error.

... java code ...
```

This file defines the package itself, and the functions in the package.
Consequently, it begins with a comment describing the `@package`, and
the goes on to document each `@function` in turn.  Some things to note:

- Each entity's documentation begins with its `@entity` tag.

- This is followed by metadata tags: `@title` for the `@package` and
  `@args` and `@result` for the `@function`.
 
- And these are followed by any number of lines of Markdown text.  All such
  lines will be accumulated and ascribed to this entity until the next entity 
  tag is seen.

## Entity Types

This section describes each entity type and its metadata.

### The `@package` Entity

The `@package` entity begins with `@package <name>`, and has the
following optional metadata:

| Metadata Tag    | Meaning                    |
|-----------------|----------------------------|
| `@title string` | Gives the package a title. |

The title string is used in the generated documentation.

For example,

```java
//**
// @package joe
// @title Joe Standard Library
// The `joe` package contains Joe's standard library.
```

### The `@function` Entity

The `@function` entity documents a global function, and 
begins with `@function <name>`.  The *name* should be the name of 
a function defined in the current package.

The entity has the following optional metadata:

| Metadata Tag       | Meaning                         |
|--------------------|---------------------------------|
| `@args <spec>`     | Names the function's arguments. |
| `@result <result>` | What the function returns.      |

The `@args` *spec* is typically a comma-delimited list of argument
names, with `...` used to indicate a variable length argument list
and square brackets used to indicate optional arguments.  Here are some
examples:

- `x`: The single argument `x`.
- `x, y`: The two arguments `x` and `y`.
- `start, [end]`: The two arguments `start` and `end`; `end` is optional.
- `x, ...`: The argument `x` plus any number of additional arguments.
- `name, value, [name, value]...`: One or more `name`,`value` pairs.

The `@args` tag can be omitted if the function takes no arguments, and
can be repeated if the function has two or more distinct signatures.[^sigs]

The `@result`'s *result* is a single token, usually either the name of 
a Joe type or a variable name like `value` or `this`.  It can be
omitted if the function returns nothing (i.e., always returns 
`null`). If the *result* names a type, it will appear as a link to that type 
in the generated documentation.

### The `@type` Entity

The `@type` entity documents a type, and so begins with `@type <name>`.

The *name* should be the name of a type defined in the current package.

At present, the `@type` entity has no metadata tags.

### The `@constant` Entity

The `@constant` entity documents a constant defined by a type, and so 
begins with `@constant <name>`. The *name* should be the name of a 
constant actually defined by the current type.

At present, the `@constant` entity has no metadata tags.

### The `@static` Entity

The `@static` entity documents a static method defined by the
current type, and begins with `@static <name>`.  The *name* should be 
the name of a static method defined by the current type.

The `@static` entity has the same metadata as the `@function` entity.

### The `@init` Entity

The `@init` entity documents the current type's initializer function.
The `@init` tag doesn't include a name, as the initializer always has
the same name as the type.

The `@init` entity accepts the `@args` metadata tag, just as any
function or method does, but not the `@result` tag, as its result is
always an instance of the current type.

### The `@method` Entity

The `@method` entity documents a method defined by the
current type, and begins with `@method <name>`.  The *name* should be
the name of a method defined by the current type.

The `@method` entity has the same metadata as the `@function` entity.

## JoeDoc Links

The Markdown content for each entity can of course contain normal
Markdown links.  In addition, though, JoeDoc supports abbreviated 
links to any entity in the documentation set.  For example,
if `[[String]]` is found in Markdown content for the `joe` package,
it will be replaced by a link to the file documenting the `String` type.

### Qualified Type Names

Every `@type` entity is defined within a package, and so has two names:
its bare or *unqualified* name, e.g., `String`, and its qualified name,
`joe.String`.

### Entity Mnemonics

Every entity can be identified in a JoeDoc link by its *mnemonic*, which
may be qualified or unqualified.  

- An entity can be linked to by its unqualified mnemonic from any Markdown
  content *in the same package*.
- An entity can be linked to by its qualified mnemonic from any Markdown
  content in the entire documentation set.

| Entity      | Qualified                      | Unqualified              |
|-------------|--------------------------------|--------------------------|
| `@package`  | `<pkg>`                        | `<pkg>`                  |
| `@function` | `<pkg>#function.<name>`        | `function.<name>`        |
| `@type`     | `<pkg>.<type>`                 | `<type>`                 | 
| `@constant` | `<pkg>.<type>#constant.<name>` | `<type>#constant.<name>` |                    
| `@static`   | `<pkg>.<type>#static.<name>`   | `<type>#static.<name>`   |                    
| `@init`     | `<pkg>.<type>#init`            | `<type>#init`            |                    
| `@method`   | `<pkg>.<type>#method.<name>`   | `<type>#method.<name>`   |                    

Thus,

- `[[joe.String#method.length]]` links to the `String` type's `length` method,
  from anywhere in the documentation set.
- `[[String#method.length]]` links to the `String` type's `length` method,
  from anywhere in the `joe` package's own documentation.

## Running `joe doc`

To run `joe doc`, `cd` to the folder containing the `joe doc` configuration
file, `doc_config.joe`, and then run `joe doc`.  In Joe's own case, it
looks like this:

```shell
$ cd joe/mdbook
$ ls doc_config.joe
doc_config.joe
$ joe doc
...
$
```

`joe doc` will report any parsing errors, duplicate entities, or unrecognized
mnemonics in JoeDoc links.

### Configuring `joe doc`

The `joe doc` configuration file, `doc_config.joe`, is itself a Joe script, 
using the API defined in the [`joe.doc`](library/pkg.joe.doc.md) package.

Joe's own `doc_config.file` looks like this (at time of writing):

```joe
DocConfig
    .inputFolder("../lib/src/main/java/com/wjduquette/joe")
    .inputFolder("../lib/src/main/resources/com/wjduquette/joe")
    .outputFolder("src/library");
```

All file paths shown are relative to the location of the `doc_config.joe`
file.

Each `inputFolder()` method names a folder that contains `.java` and/or `.joe` 
files to scan for doc comments.  `joe doc` will scan for such files in the
named folder, recursing down into subfolders.  

There is also an `inputFile()` method that names a specific file to scan.

The `outputFolder()` method names the folder to receive the generated
documentation files.

### Generated Files

When run, `joe doc` produces the following files, all within the configured
output directory.

- `index.md`: A detailed index of the entire documentation set, e.g.,
  the Joe [Library API Index](library/index.md).
- `pkg.<pkg>.md`: The package file for the given package., e.g., 
  [pkg.joe.md](library/pkg.joe.md)
- `type.<pkg>.<type>.md`: The type file for the given type, e.g.,
  [`type.joe.String.md`](library/type.joe.String.md)

The link IDs for the functions in a package file, and for the methods
and other entities in a type file, are exactly the same as in the
[entity mnemonics](#entity-mnemonics).  Thus, to link to the `length` 
method of the `String` type from outside the documentation set, you'd
use the partial URL `<folder>/type.joe.String.md#method.length`.

[^markdown]: This User's Guide is
produced using [mdBook](https://github.com/rust-lang/mdBook), and so
`joe doc` produces output in a form compatible with `mdBook`.  It should
be usable with any other static site generator that works with Markdown
files.

[^sigs]: Joe does not allow for overloaded function and method names, but
a single function or method can simulate overloading through the use of
a variable length argument list.  This technique is common in
[native functions](extending/native_functions.md) and methods.