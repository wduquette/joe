# 'joe doc'

The `joe doc` processor is used to extract JoeDoc documentation comments
from `.java` and `.joe` source files, and generate Markdown 
API documentation from them.[^markdown] 

The [API sections](library.md) of this user's guide were generated by
`joe doc`.

- [Documentation Set](#documentation-set)
  - [Documentation Comments](#documentation-comments)
  - [Entry Tags](#entry-tags)
  - [Example](#example)
- [Entry Types](#entry-types)
  - [The `@package` Entry](#the-package-entry)
  - [The `@packageTopic` Entry](#the-packagetopic-entry)
  - [The `@function` Entry](#the-function-entry)
  - [The `@type` Entry](#the-type-entry)
  - [The `@class` Entry](#the-class-entry)
  - [The `@record` Entry](#the-record-entry)
  - [The `@enum` Entry](#the-enum-entry)
  - [The `@widget` Entry](#the-widget-entry)
  - [The `@singleton` Entry](#the-singleton-entry)
  - [The `@typeTopic` Entry](#the-typetopic-entry)
  - [The `@constant` Entry](#the-constant-entry)
  - [The `@static` Entry](#the-static-entry)
  - [The `@init` Entry](#the-init-entry)
  - [The `@field` Entry](#the-field-entry)
  - [The `@property` Entry](#the-property-entry)
  - [The `@method` Entry](#the-method-entry)
  - [The `@mixin` Entry](#the-mixin-entry)
- [JoeDoc Links](#joedoc-links)
  - [Qualified Type Names](#qualified-type-names)
  - [Entry Mnemonics](#entry-mnemonics)
- [Running `joe doc`](#running-joe-doc)
  - [Configuring `joe doc`](#configuring-joe-doc)
  - [Generated Files](#generated-files)

## Documentation Set

A *documentation set* is the generated JoeDoc documentation for the
packages in the current project.  It will include documentation for the
following types of entry:

- Packages
  - Functions
  - Types (including Enums)
    - Constants
    - Static Methods
    - Initializers
    - Fields
    - Methods
  - Additional topics concerning a specific package or type
- Mixins
  - A pseudo-type used for documentation content to be included in
    multiple types.

Unsurprisingly, this is the same structure you'll find in the 
[Extending Joe](extending/extending.md) section.  And unsurprisingly,
the generated documentation has this same structure.

### Documentation Comments

A documentation comment is a block of comments beginning with the following
marker comment: `//**` and continuing through contiguous comment lines until
the next non-comment line:

```java
// Not in a doc comment

//**
// @package my.package
//
// Information about `my.package` in Markdown format.
// ...

// Not in a doc comment
```

The comment prefix `//` must be the first non-whitespace text on each line.

`joe doc` extracts all doc comment lines from a source file, removes the 
comment prefixes, and then parses them to extract the documentation 
according to its structure.

### Entry Tags

In the example just shown, the tag `@package` indicates that the following 
comment text concerns the named package.  `joe doc` understands the following
entry tags.

- [`@package <name>`](#the-package-entry)
  - [`@function <name>`](#the-function-entry)
  - [`@type <name>`](#the-type-entry)
    - [`@constant <name> <valueType>`](#the-constant-entry)
    - [`@static <name>`](#the-static-entry)
    - [`@init`](#the-init-entry)
    - [`@field <name> <valueType>`](#the-field-entry)
    - [`@property <name> <valueType>`](#the-property-entry)
    - [`@method <name>`](#the-method-entry)
    - [`@typeTopic <name>`](#the-typetopic-entry)
  - [`@packageTopic <name>`](#the-packagetopic-entry)
- [`@mixin <name>`](#the-mixin-entry)
  - [`@constant <name> <valueType>`](#the-constant-entry)
  - [`@static <name>`](#the-static-entry)
  - [`@field <name> <valueType>`](#the-field-entry)
  - [`@method <name>`](#the-method-entry)
  - [`@typeTopic <name>`](#the-typetopic-entry)

**Note:** `@class`, `@record`, `@enum`, `@widget`, and `@singleton` are
effectively identical to `@type`, except as described in the relevant
sections.

This is the same outline [shown above](#documentation-set), and 
purposely so.  Each entry has a parent, and the parentage is indicated 
by the outline.

- `@package` and `@mixin` entities belong to the documentation set.
- Every `@function` and `@type` entry belongs to the `@package` that
  most nearly precedes it in the same file.
- Every `@constant`, `@static`, `@init`, `@field`, `@property`, and 
 `@method` entry belongs to
  the `@type` or `@mixin` that most nearly precedes it in the same file. 
- It's an error if the expected parent entry is missing.
- `joe doc` checks carefully for duplicate names.
- A `@type` can have at most a single `@init` (initializer) entry; and it 
  has no name because it always has the same name as its type.

Packages are special; a single Joe package's code is often spread across 
a number of files. Thus, the same `@package` name can appear in multiple
files, and the related entities will all be ascribed to the same package.

A single source file may (in principle) contain documentation for multiple
mixins, packages and types.  If `joe doc` sees a second `@package`, 
it immediately switches to that `@package`, and so for the others.

### Example

Here is the beginning of the documentation in Joe's `StandardLibrary.java`
file:

```java
//**
// @package joe
// %title Joe Standard Library
// The `joe` package contains Joe's standard library.

... java code ...

//**
// @function catch
// %args callable
// %result CatchResult
// Executes the callable, which must not require any arguments.
// Returns a \[[CatchResult]] indicating success or failure and providing
// the returned result or the error message respectively.
        
... java code ...
```

This file defines the package itself, and the functions in the package.
Consequently, it begins with a comment describing the `@package`, and
the goes on to document each `@function` in turn.  Some things to note:

- Each entry's documentation begins with its `@entry` tag.

- This is followed by metadata tags: `%title` for the `@package` and
  `%args` and `%result` for the `@function`.
 
- And these are followed by any number of lines of Markdown text.  All such
  lines will be accumulated and ascribed to this entry until the next entry 
  tag is seen.

## Entry Types

This section describes each entry type and its metadata.

### The `@package` Entry

The `@package` entry begins with `@package <name>`, and has the
following optional metadata:

| Metadata Tag    | Meaning                    |
|-----------------|----------------------------|
| `%title string` | Gives the package a title. |

The title string is used in the generated documentation.

The `@package` entry may have 
[`@function`](#the-function-entry), 
[`@type`](#the-type-entry), and 
[`@packageTopic`](#the-packagetopic-entry) children.

For example,

```java
//**
// @package joe
// %title Joe Standard Library
// The `joe` package contains Joe's standard library.
```

### The `@packageTopic` Entry

A package's normal Markdown content goes near the top of the generated
package page, below the index but above the function entries.  The
`@packageTopic` entry is way to add titled Markdown content at the
*bottom* of the package file, where it is out of the way.

The `@packageTopic` entry begins with `@packageTopic <name>`, and has
the following metadata:

| Metadata Tag    | Meaning                  |
|-----------------|--------------------------|
| `%title string` | Gives the topic a title. |

The title string is used as a header in the generated content, and in
links to that content.  In theory the `%title` tag is optional, but 
in practice one always wants to use it.


### The `@function` Entry

The `@function` entry documents a global function, and 
begins with `@function <name>`.  The *name* should be the name of 
a function defined in the current package.

The entry has the following optional metadata:

| Metadata Tag       | Meaning                         |
|--------------------|---------------------------------|
| `%args <spec>`     | Names the function's arguments. |
| `%result <result>` | What the function returns.      |

The `%args` *spec* is typically a comma-delimited list of argument
names, with `...` used to indicate a variable length argument list
and square brackets used to indicate optional arguments.  Here are some
examples:

- `x`: The single argument `x`.
- `x, y`: The two arguments `x` and `y`.
- `start, [end]`: The two arguments `start` and `end`; `end` is optional.
- `x, ...`: The argument `x` plus any number of additional arguments.
- `name, value, [name, value]...`: One or more `name`,`value` pairs.

The `%args` tag can be omitted if the function takes no arguments, and
can be repeated if the function has two or more distinct signatures.[^sigs]

The `%result`'s *result* is a single token, usually either the name of 
a Joe type or a variable name like `value` or `this`.  It can be
omitted if the function returns nothing (i.e., always returns 
`null`). If the *result* names a type, it will appear as a link to that type 
in the generated documentation.

### The `@type` Entry

The `@type` entry documents a type, and so begins with `@type <name>`. The 
*name* should be the name of a type defined in the current package.

The entry has the following optional metadata:

| Metadata Tag             | Meaning                                              |
|--------------------------|------------------------------------------------------|
| `%extends <type>`        | This type extends the named type.                    |
| `%includeMixin <mixin>`  | This type's documentation includes the named mixin.  |
| `%javaType <className>`  | The underlying Java type's full class name.          |
| `%proxyType <className>` | The underlying Java `ProxyType`'s full class name.   |
| `%enumConstants`         | **Enums Only**: Auto-populates the enum's constants. |

The `%extends <type>` tag is used when this type extends (i.e., subclasses) 
another script-visible type.  The `<type>` should be the name or qualified name 
of a referenced `@type`.

The `@includesMixin <mixin>` tag indicates that this type's documentation should 
include the documentation from a [`@mixin`](#the-mixin-entry) defined in this 
documentation set. The included documentation will be represented as part of 
the including type.

The `@type` entry may have 
[`@constant`](#the-constant-entry),
[`@static`](#the-static-entry),
[`@init`](#the-init-entry),
[`@field`](#the-field-entry),
[`@property`](#the-property-entry),
[`@method`](#the-method-entry),
and
[`@typeTopic`](#the-method-entry)
children.

For example, in the standard library the [`AssertError`](library/type.joe.AssertError.md) type extends the
[`Error`](library/type.joe.Error.md) type, both of which are visible at the script-level.


```java
//**
// @type AssertError
// %extends Error
// ...
```

### The `@class` Entry

The `@class` entry is for types that are Joe `classes` or can be
extended by Joe `classes`.  It is functionally equivalent to `@type`,
except that `@class` entries are described as classes in the generated
documentation.

### The `@record` Entry

The `@record` entry is for types that are Joe `records` or are
native types that behavior like them. It is functionally equivalent to 
`@type`, except that `@record` entries are described as records in the 
generated documentation.

### The `@enum` Entry

The `@enum` entry documents a native Java enumerated type whose
binding is created using Joe's `EnumProxy<E>` type proxy class. An 
`@enum` entry is just like a [`@type` entry](#the-type-entry),
except that it automatically includes documentation for the enum's static 
methods, `values()` and `valueOf`, and for the enum's instance methods,
`name()`, `ordinal()`, and `toString()`.

A simple `@enum` doc comment will usually need to include only a description
of the enum and the enum's `@constant` entities. If the specific enum
defines other static or instance methods, they can be included as well.

If the Java enum is known to `joe doc`, the constants can be added
automatically: provide the `%javaType` and `%enumConstants` metadata tags: 

```java
//**
// @enum MyEnum
// %javaType my.project.MyEnum
// %enumConstants
// ... content ...
```

### The `@widget` Entry

The `@widget` entry is for JavaFX widgets. It is functionally equivalent 
to `@type`, except that `@widget` entries are described as widgets in the
generated documentation.

### The `@singleton` Entry

The `@singleton` entry is for singleton types: types having only 
constants and static methods. It is functionally equivalent
to `@type`, except that `@singleton` entries are described as 
singletons in the generated documentation.

### The `@typeTopic` Entry

A type's normal Markdown content goes near the top of the generated
type page, below the index but above the various constant and method 
entries.  The `@typeTopic` entry is way to add titled Markdown content 
at the *bottom* of the type's file, where it is out of the way.

The `@typeTopic` entry begins with `@typeTopic <name>`, and has
the following metadata:

| Metadata Tag    | Meaning                  |
|-----------------|--------------------------|
| `%title string` | Gives the topic a title. |

The title string is used as a header in the generated content, and in
links to that content.  In theory the `%title` tag is optional, but
in practice one always wants to use it.

As an example, the [`String` type](library/type.joe.String.md) uses a
`@typeTopic` to document its 
[format string syntax](library/type.joe.String.md#topic.formatting).

### The `@constant` Entry

The `@constant` entry documents a constant defined by a type, and so 
begins with `@constant <name> [<valueType>]`. The *name* should be the 
name of a constant actually defined by the current type.  If given, the
*valueType* will appear as the constant's value type in the generated
documentation, and will link to the type's page as though it were
a mnemonic.

At present, the `@constant` entry has no metadata tags.

### The `@static` Entry

The `@static` entry documents a static method defined by the
current type, and begins with `@static <name>`.  The *name* should be 
the name of a static method defined by the current type.

The `@static` entry has the same metadata as the `@function` entry.

### The `@init` Entry

The `@init` entry documents the current type's initializer function.
The `@init` tag doesn't include a name, as the initializer always has
the same name as the type.

The `@init` entry accepts the `%args` metadata tag, just as any
function or method does, but not the `%result` tag, as its result is
always an instance of the current type.

### The `@field` Entry

The `@field` entry documents an instance field defined by the current type,
and begins with `@field <name> [<valueType>]` where the *name* is the 
name of the field. If given, the
*valueType* will appear as the field's value type in the generated
documentation, and will link to the type's page as though it were
a mnemonic. 

The entry has Markdown content but no metadata tags.

### The `@property` Entry

The `@property` entry documents a JavaFX `Property` defined by the 
current type, and begins with `@property <name> [<valueType>]` where 
the *name* is the name of the property. If given, the
*valueType* will appear as the property's value type in the generated
documentation, and will link to the type's page as though it were
a mnemonic.

The entry has Markdown content but no metadata tags.

### The `@method` Entry

The `@method` entry documents a method defined by the
current type, and begins with `@method <name>`.  The *name* should be
the name of a method defined by the current type.

The `@method` entry has the same metadata as the `@function` entry.

### The `@mixin` Entry

The `@mixin` entry is like a pseudo-`@type`; it contains type content that
would otherwise be duplicated in multiple `@type` entries.  Mixin entities
belong to the documentation set, not to any specific package, and may be
included by any `@type` entry.

Every mixin begins with `@mixin <name>`; mixin names must be unique within
the documentation set.

Mixins have no metadata tags, and may have Markdown content and
[`@constant`](#the-constant-entry),
[`@static`](#the-static-entry),
[`@field`](#the-field-entry),
[`@method`](#the-method-entry),
and
[`@typeTopic`](#the-method-entry)
children.

When a type wants to include a mixin, it uses the `@includesMixin <name>`
metadata tag.  

- The mixin's Markdown content is inserted into the type's
  Markdown content at the location of the `@includesMixin` tag
- The mixin's children are then added to the type.

A mixin is like a template; the string `<type>` may be included anywhere
in the content of the mixin itself and its children, and will be replaced
on inclusion by the including type's name.

For example, the mixin might define:

```java
//**
// @mixin MyMixin
// 
// The `<type>` type is able to...
//
// @method myMethod
// %result <type>
// This method...
```

Then, another type can include it like this:

```java
//**
// @type MyType
// The `MyType` type represents...
//
// %includeMixin MyMixin
//
// The MyMixin Markdown content is included above, replacing the include tag.
```

## JoeDoc Links

The Markdown content for each entry can of course contain normal
Markdown links.  In addition, though, JoeDoc supports abbreviated 
links to any entry in the documentation set.  For example,
if `\[[String]]` is found in Markdown content for the `joe` package,
it will be replaced by a link to the file documenting the `String` type.

### Qualified Type Names

Every `@type` entry is defined within a package, and so has two names:
its bare or *unqualified* name, e.g., `String`, and its qualified name,
`joe.String`.

### Entry Mnemonics

Every entry can be identified in a JoeDoc link by its *mnemonic*, which
may be qualified or unqualified.  

- An entry can be linked to by its unqualified mnemonic from any Markdown
  content *in the same package*.
- An entry can be linked to by its qualified mnemonic from any Markdown
  content in the entire documentation set.

| Entry           | Qualified                      | Unqualified              |
|-----------------|--------------------------------|--------------------------|
| `@package`      | `<pkg>`                        | `<pkg>`                  |
| `@packageTopic` | `<pkg>#topic.<name>`           | `<pkg>#topic.<name>`     |
| `@function`     | `<pkg>#function.<name>`        | `function.<name>`        |
| `@type`         | `<pkg>.<type>`                 | `<type>`                 | 
| `@typeTopic`    | `<pkg>.<type>#topic.<name>`    | `<type>#topic.<name>`    |
| `@constant`     | `<pkg>.<type>#constant.<name>` | `<type>#constant.<name>` |                    
| `@static`       | `<pkg>.<type>#static.<name>`   | `<type>#static.<name>`   |                    
| `@init`         | `<pkg>.<type>#init`            | `<type>#init`            |                    
| `@field`        | `<pkg>.<type>#field.<name>`    | `<type>#field.<name>`    |                    
| `@property`     | `<pkg>.<type>#property.<name>` | `<type>#property.<name>` |                    
| `@method`       | `<pkg>.<type>#method.<name>`   | `<type>#method.<name>`   |                    

Thus,

- `\[[joe.String#method.length]]` links to the `String` type's `length` method,
  from anywhere in the documentation set.
- `\[[String#method.length]]` links to the `String` type's `length` method,
  from anywhere in the `joe` package's own documentation.

## Running `joe doc`

To run `joe doc`, `cd` to the folder containing the `joe doc` configuration
file, `doc_config.joe`, and then run `joe doc`.  In Joe's own case, it
looks like this:

```shell
$ cd joe/mdbook
$ ls doc_config.joe
doc_config.joe
$ joe doc
...
$
```

`joe doc` will report any parsing errors, duplicate entities, or unrecognized
mnemonics in JoeDoc links.

### Configuring `joe doc`

The `joe doc` configuration file, `doc_config.joe`, is itself a Joe script, 
using the API defined in the [`joe.doc`](library/pkg.joe.doc.md) package.

Joe's own `doc_config.file` looks like this (at time of writing):

```joe
DocConfig
    .inputFolder("../lib/src/main/java/com/wjduquette/joe")
    .inputFolder("../lib/src/main/resources/com/wjduquette/joe")
    .outputFolder("src/library");
```

All file paths shown are relative to the location of the `doc_config.joe`
file.

Each `inputFolder()` method names a folder that contains `.java` and/or `.joe` 
files to scan for doc comments.  `joe doc` will scan for such files in the
named folder, recursing down into subfolders.  

There is also an `inputFile()` method that names a specific file to scan.

The `outputFolder()` method names the folder to receive the generated
documentation files.

### Generated Files

When run, `joe doc` produces the following files, all within the configured
output directory.

- `index.md`: A detailed index of the entire documentation set, e.g.,
  the Joe [Library API Index](library/index.md).
- `pkg.<pkg>.md`: The package file for the given package., e.g., 
  [pkg.joe.md](library/pkg.joe.md)
- `type.<pkg>.<type>.md`: The type file for the given type, e.g.,
  [`type.joe.String.md`](library/type.joe.String.md)

The link IDs for the functions in a package file, and for the methods
and other entities in a type file, are exactly the same as in the
[entry mnemonics](#entry-mnemonics).  Thus, to link to the `length` 
method of the `String` type from outside the documentation set, you'd
use the partial URL `<folder>/type.joe.String.md#method.length`.

[^markdown]: This User's Guide is
produced using [mdBook](https://github.com/rust-lang/mdBook), and so
`joe doc` produces output in a form compatible with `mdBook`.  It should
be usable with any other static site generator that works with Markdown
files.

[^sigs]: Joe does not allow for overloaded function and method names, but
a single function or method can simulate overloading through the use of
a variable length argument list.  This technique is common in
[native functions](extending/native_functions.md) and methods.
