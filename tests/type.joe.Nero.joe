// type.joe.Nero.joe

//-----------------------------------------------------------------------------
// Pipeline Execution

function testDebug() {
    var nero = Nero();
    var rules = ruleset {
        define Parent/p,c;
        Parent(#anne, #bert);
    };
    
    // Just verify that the debug flag can be set.
    nero.with(rules).debug().debug(false);
}

function testInfer() {
    var nero = Nero();
    var rules = ruleset {
        define Parent/p,c;
        define Ancestor/a,d;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
        Ancestor(x, y) :- Parent(x, y);
        Ancestor(x, y) :- Parent(x, z), Ancestor(z, y);
    };
    var results = nero.toNeroScript(nero.with(rules).infer()).strip();
    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        
        define Parent/p,c;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
        """);
}

function testUpdate() {
    var nero = Nero();
    var rules1 = ruleset {
        define Parent/p,c;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
    };
    var rules2 = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
        Ancestor(x, y) :- Parent(x, z), Ancestor(z, y);
    };
    var facts = nero.with(rules1).infer();
    var results = nero.toNeroScript(nero.with(rules2).update(facts)).strip();
    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);

        define Parent/p,c;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
        """);
}

function testQuery() {
    var nero = Nero();
    var rules1 = ruleset {
        define Parent/p,c;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
    };
    var rules2 = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
        Ancestor(x, y) :- Parent(x, z), Ancestor(z, y);
    };
    var facts = nero.with(rules1).infer();
    var results = nero.toNeroScript(nero.with(rules2).query(facts)).strip();
    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

//-----------------------------------------------------------------------------
// Inputs and Automatic Fact Conversions
//
// These tests test the conversion of various non-Fact types into Facts by 
// the Nero pipeline.  They are tested here rather than in NeroTest because
// they require scripted Joe types.

// Should throw an error if an input fact has no fields.
function testWith_noFields() {
    class Parent {
        method toString() { return "Parent()"; }
    }

    var inputs = [
        Parent()
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
    };

    var nero = Nero();
    assertError(\-> nero.with(rules).update(inputs),
        "Expected Nero-compatible fact, got: Parent 'Parent()'.");
    assertError(\-> nero.with(rules).query(inputs),
        "Expected Nero-compatible fact, got: Parent 'Parent()'.");
}

// Should accept proxied values with
// fields, including the Fact type itself.
function testWith_proxiedValue_ordered() {
    var inputs = [
        Fact.ofPairs("Parent", ["p", #anne, "c", #bert]),
        Fact.ofPairs("Parent", ["p", #bert, "c", #clark])
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
        Ancestor(x, y) :- Parent(x, z), Ancestor(z, y);
    };
    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

// Should accept proxied values with
// fields, including the Fact type itself, using named atoms
function testWith_proxiedValue_named() {
    var inputs = [
        Fact.ofPairs("Parent", ["p", #anne, "c", #bert]),
        Fact.ofPairs("Parent", ["p", #bert, "c", #clark])
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(p:x, c:y);
        Ancestor(x, y) :- Parent(p:x, c:z), Ancestor(z, y);
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

// Should accept record instances using
// ordered-field atoms.
function testWith_record_ordered() {
    record Parent(p, c) {}
    var inputs = [
        Parent(#anne, #bert),
        Parent(#bert, #clark)
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
        Ancestor(x, y) :- Parent(x, z), Ancestor(z, y);
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

// Should accept record instances using
// named-field atoms
function testWith_record_named() {
    record Parent(p, c) {}
    var inputs = [
        Parent(#anne, #bert),
        Parent(#bert, #clark)
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(p:x, c:y);
        Ancestor(x, y) :- Parent(p:x, c:z), Ancestor(z, y);
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

// Should accept class instances with fields, provided that 
// named-field atoms are used to match them.
function testWith_class_named() {
    class Parent {
        method init(p, c) {
            @p = p;
            @c = c;
        }
        method toString() {
            return "Parent(" + @p + ", " + @c + ")";
        }
    }

    var inputs = [
        Parent(#anne, #bert),
        Parent(#bert, #clark)
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(p:x, c:y);
        Ancestor(x, y) :- Parent(p:x, c:z), Ancestor(z, y);
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define Ancestor/a,d;
        Ancestor(#anne, #bert);
        Ancestor(#anne, #clark);
        Ancestor(#bert, #clark);
        """);
}

// Should throw an error if an ordered-field atom is used with a 
// fact that does not have ordered fields.
function testWith_class_ordered() {
    class Parent {
        method init(p, c) {
            @p = p;
            @c = c;
        }
        method toString() {
            return "Parent(" + @p + ", " + @c + ")";
        }
    }

    var inputs = [
        Parent(#anne, #bert),
        Parent(#bert, #clark)
    ];

    var rules = ruleset {
        define Ancestor/a,d;
        Ancestor(x, y) :- Parent(x, y);
    };

    var nero = Nero();
    assertError(\-> nero.with(rules).query(inputs),
        "'Parent' in rule 'Ancestor(x, y) :- Parent(x, y);' requires ordered fields, but a provided fact is not ordered.");
}

function testWith_namedPattern() {
    class Thing {
        method init(id, color) {
            @id = id;
            @color = color;
        }
    }

    var inputs = [
        Fact.ofPairs("A", ["id", #a, "color", Thing(#hat, #black)]),
        Fact.ofPairs("A", ["id", #b, "color", Thing(#wagon, #red)])
    ];

    var rules = ruleset {
        define B/x,y,z;

        B(x, y, z) :- A(x, Thing(id: y, color: z));
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define B/x,y,z;
        B(#a, #hat, #black);
        B(#b, #wagon, #red);
        """);
}

function testPattern_ordered() {
    record Thing(id, color) {}

    var inputs = [
        Fact.ofPairs("A", ["id", #a, "color", Thing(#hat, #black)]),
        Fact.ofPairs("A", ["id", #b, "color", Thing(#wagon, #red)])
    ];

    var rules = ruleset {
        define B/x,y,z;
        B(x, y, z) :- A(x, Thing(y, z));
    };

    var nero = Nero();
    var results = nero.toNeroScript(nero.with(rules).query(inputs)).strip();

    assertEQ(results, """
        define B/x,y,z;
        B(#a, #hat, #black);
        B(#b, #wagon, #red);
        """);
}

//-----------------------------------------------------------------------------
// Equivalences

var S2N = Equivalence(#str2num,
    \s -> s ~ String() ? Number(s) : null,
    \n -> n ~ Number() ? Joe.stringify(n) : null
);

function testEquivalence() {
    var nero = Nero();
    nero.equivalence(S2N);
    assertEQ(nero.getEquivalences(), {S2N});
}

function testEquivalences_individual() {
    var nero = Nero();
    nero.equivalences(S2N);
    assertEQ(nero.getEquivalences(), {S2N});
}

function testEquivalences_individual() {
    var nero = Nero();
    nero.equivalences(S2N);
    assertEQ(nero.getEquivalences(), {S2N});
}

function testEquivalences_collection() {
    var nero = Nero();
    nero.equivalences([S2N]);
    assertEQ(nero.getEquivalences(), {S2N});
}

function testUseEquivalence() {
    var nero = Nero();
    var rules = ruleset {
        define transient Str/s;
        define Both/s,n;

        Str("123");
        Both(s,n) :- Str(s), equivalent(#str2num, s, n);
    };
    var results = nero.toNeroScript(nero.with(rules).infer()).strip();
    assertEQ(results, """
        define Both/s,n;
        Both("123", 123);
        """);
}

//-----------------------------------------------------------------------------
// toNero*

// toNeroScript is tested in-line above.

function testToNeroAxiom() {
    var nero = Nero();
    var rules = ruleset {
        define Parent/p,c;
        Parent(#anne, #bert);
        Parent(#bert, #clark);
    };
    var facts = nero.with(rules).infer();
    var list = facts.map(nero.toNeroAxiom).sorted();
    assertEQ(list, [
        "Parent(#anne, #bert);",
        "Parent(#bert, #clark);",
    ]);
}
