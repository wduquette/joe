// lang_pattern.joe
//
// This test tests Joe's pattern matching syntax in detail, using the
// `~` operator.  Other test suites (`lang_var.joe`, etc.)
// test pattern matching in specific contexts.

//----------------------------------------------------------------------------
// Simple Patterns

// Verify that a binding variable matches anything.
function testOneVar() {
    assertT(1 ~ a);
    assertEQ(a, 1);
}

// Verify that a wildcard matches anything, and doesn't create a binding.
function testWildcard() {
    var _ = 5;
    assertT(1 ~ _);
    assertEQ(_, 5);
}

// Verify that a literal constant only matches the same value.
function testLiteralConstant() {
    assertT(1 ~ 1);
    assertF(1 ~ 2);
}

// Verify that an interpolated variable yields a constant.
function testInterpolatedVariable() {
    var x = 1;
    var y = 2;
    assertT(1 ~ $x);
    assertF(1 ~ $y);
}

// Verify that an interpolated expression yields a constant.
function testInterpolatedExpression() {
    assertT(2 ~ $(1 + 1));
    assertF(1 ~ $(1 + 1));
}

//-------------------------------------------------------------------------
// List Patterns

function testList_noMatch() {
    assertF(5 ~ [1, 2]);
}

function testList_noTail() {
    assertT([1, 2] ~ [a, b]);
    assertEQ(a, 1);
    assertEQ(b, 2);
}

function testList_emptyTail() {
    assertT([1, 2] ~ [a, b : c]);
    assertEQ(a, 1);
    assertEQ(b, 2);
    assertEQ(c, []);
}

function testList_fullTail() {
    assertT([1, 2, 3, 4] ~ [a, b : c]);
    assertEQ(a, 1);
    assertEQ(b, 2);
    assertEQ(c, [3, 4]);
}

function testList_nestedPattern() {
    assertT([1, [2, 3], 4] ~ [a, [b, c], d]);
    assertEQ(a, 1);
    assertEQ(b, 2);
    assertEQ(c, 3);
    assertEQ(d, 4);
}

//-------------------------------------------------------------------------
// Map Patterns

function testMap_matchEmptyMap() {
    // The {} pattern should be "{:}".
    assertT({:} ~ {:});
}

// Value isn't a map
function testMap_noMap() {
    assertF(5 ~ {#abc: a});
}

// Value is a map, but is missing a key that appears in the pattern.
function testMap_missingKey() {
    assertF({#def: 5} ~ {#abc: a});
}

// Value has the right keys, but one of the values is wrong.
function testMap_valueMismatch() {
    assertF({#abc: 5, #def: 6} ~ {#abc: a, #def: 7});
}

// The pattern matches.
function testMap_good() {
    assertT({"abc": 5, "def": 6} ~ {"abc": a});
    assertEQ(a, 5);
}

// Map keys can be interpolated into the pattern.
function testMap_interpolatedKey() {
    var key = #joe;
    assertT({#joe: #value} ~ {$key: value});
    assertEQ(value, #value);
}

//-----------------------------------------------------------------------------
// Named-Field Patterns

// Can't match a value that has no script-visible fields.
function testNamedField_noFields() {
    assertF("abc" ~ Thing(id: id));
}

// Can't match a value of the different type.
function testNamedField_valueWrongType() {
    var thing = Thing(123, "red");

    assertF(thing ~ Gizmo(id: id));
}

// Can't match if a pattern field doesn't exist in the value.
function testNamedField_unknownField() {
    var thing = Thing(123, "red");

    assertF(thing ~ Thing(id: id, style: s));
}

// Can match if the type name and the field names match.
function testNamedField_good() {
    var thing = Thing(123, "red");

    assertT(thing ~ Thing(id: i, color: c));
    assertEQ(i, thing.id);
    assertEQ(c, thing.color);
}

// Can match if the pattern names a supertype of the value.
function testNamedField_supertype_good() {
    var gizmo = Gizmo(123, "red");

    assertT(gizmo ~ Thing(id: i, color: c));
    assertEQ(i, gizmo.id);
    assertEQ(c, gizmo.color);
}

// Can match a Fact by its relation
function testNamedField_fact_byRelation() {
    var person = Fact.ofPairs("Person", ["n", "Joe", "a", 80]);
    assertT(person ~ Person(n: name, a: age));
    assertEQ(name, person.n);
    assertEQ(age, person.a);
}

// Can match a Fact as a Fact
function testNamedField_fact_asFact() {
    var person = Fact.ofPairs("Person", ["n", "Joe", "a", 80]);
    assertT(person ~ Fact(relation: "Person", fields: {"n": name, "a": age}));
    assertEQ(name, person.n);
    assertEQ(age, person.a);
}

//-----------------------------------------------------------------------------
// Ordered-Field Patterns

// Can't match a value with unordered fields
function testOrderedField_notOrdered() {
    assertF(Thing(123, "red") ~ Thing(id, color));
}

// Can't match if the type is wrong.
function testOrderedField_wrongType() {
    var person = Person("Joe", 80);

    assertF(person ~ PersonNonGrata(name, age));
}

// Can match if the number of fields is correct.
function testOrderedField_good() {
    var person = Person("Joe", 80);

    assertT(person ~ Person(name, age));
    assertEQ(name, person.name);
    assertEQ(age, person.age);
}

// Can match a Fact by its relation provided that it has ordered fields.
function testOrderedField_fact_byRelation() {
    var person = Fact.ofPairs("Person", ["n", "Joe", "a", 80]);
    assertT(person ~ Person(name, age));
    assertEQ(name, person.n);
    assertEQ(age, person.a);
}

// Can match a Fact by its relation provided that it has ordered fields.
function testOrderedField_fact_asFact() {
    var person = Fact.ofPairs("Person", ["n", "Joe", "a", 80]);
    assertT(person ~ Fact("Person", [name, age]));
    assertEQ(name, person.n);
    assertEQ(age, person.a);
}

//-----------------------------------------------------------------------------
// Pattern-Bindings

function testPatternBinding_atTop() {
    assertT([1, 2] ~ a@[b, c]);
    assertEQ(a, [1, 2]);
    assertEQ(b, 1);
    assertEQ(c, 2);
}

function testPatternBinding_nested() {
    assertT([1, [2, 3], 4] ~ [a, b@[c, d], e]);
    assertEQ(a, 1);
    assertEQ(b, [2, 3]);
    assertEQ(c, 2);
    assertEQ(d, 3);
    assertEQ(e, 4);
}

//-----------------------------------------------------------------------------
// TypeNames

// Matches on type only for any type.
function testTypeName_joeValue() {
    record Gizmo(x, y) {}
    var gizmo = Gizmo(1, 2);
    assertT(gizmo ~ Gizmo());
    assertF(gizmo ~ Number());
    assertT("abc" ~ String());
    assertF("abc" ~ Number());
}

// For facts, matches on `Fact` or the relation.
function testTypeName() {
    var fact = Fact.ofPairs("Thing", ["n", #a]);
    assertT(fact ~ Fact());
    assertT(fact ~ Thing());
    assertF(fact ~ String());
}

//-----------------------------------------------------------------------------
// Helpers

class Thing {
    method init(id, color) {
        @id = id;
        @color = color;
    }
}

class Gizmo extends Thing {
    method init(id, color) {
        super.init(id, color);
    }
}

record Person(name, age) {}
