// Operator Tests
//
// Language tests should confine themselves to the basic test API.

//-----------------------------------------------------------------------------
// Arithmetic Operators

function testPlus() {
    assertEQ(1 + 2, 3);
    assertEQ("a" + "b", "ab");
    assertEQ("a" + 1, "a1");
    assertEQ(1 + "a", "1a");

    function bad() { #a + #b; }
    assertError(bad, "The '+' operator expects two Numbers or at least one String.");
}

function testMinus() {
    assertEQ(4 - 1, 3);
    assertEQ(1 - 4, -3);

    function bad() { 4 - "abc"; }
    assertError(bad, "The '-' operator expects two numeric operands.");
}

function testTimes() {
    assertEQ(4 * 2, 8);

    function bad() { 4 * "abc"; }
    assertError(bad, "The '*' operator expects two numeric operands.");
}

function testDivide() {
    assertEQ(4/2, 2);
    assertEQ(String(4/0), "Infinity");  // TODO: support Infinity,  NaN

    function bad() { 4 / "abc"; }
    assertError(bad, "The '/' operator expects two numeric operands.");
}

//-----------------------------------------------------------------------------
// Test Comparisons

function testEquals() {
    assertT(1 == 1);
    assertT("a" == "a");
    assertT(#k == #k);
    assertF(1 == 2);
    assertF("a" == #k);
}

function testNotEquals() {
    assertF(1 != 1);
    assertT(1 != 2);
    assertT("a" != #k);
}

function testComparisons() {
    assertT(0 < 1);
    assertF(1 < 1);
    assertT("a" < "b");
    assertF("b" < "a");

    assertT(0 <= 1);
    assertT(1 <= 1);
    assertF(2 <= 1);
    assertT("a" <= "b");
    assertT("a" <= "a");
    assertF("b" <= "a");

    assertF(0 > 0);
    assertT(1 > 0);
    assertF("a" > "a");
    assertT("b" > "a");

    assertT(1 >= 0);
    assertT(1 >= 1);
    assertF(1 >= 2);
    assertT("b" >= "a");
    assertT("b" >= "b");
    assertF("b" >= "c");

    function bad() { "a" > 1; }
    assertError(bad, "The '>' operator expects two Numbers or two Strings.");
}

//-----------------------------------------------------------------------------
// Logical Operators

function testAnd() {
    // With booleans
    assertT(true && true);
    assertF(true && false);
    assertF(false && true);
    assertF(false && false);

    // Returns first argument if first is falsey.
    assertF(false && 1);
    assertEQ(null && 1, null);

    // Returns second argument if first is truthy
    assertEQ(1 && 2, 2);
    assertEQ(1 && null, null);
}

function testOr() {
    // With booleans
    assertT(true || true);
    assertT(true || false);
    assertT(false || true);
    assertF(false || false);

    // Returns first argument if first is truthy.
    assertT(true || false);
    assertEQ(1 || null, 1);

    // Returns second argument if first is falsy
    assertEQ(false || 2, 2);
    assertEQ(null || 4, 4);
}

function testNot() {
    assertF(!true);
    assertF(!1);
    assertT(!false);
    assertT(!null);
}

//-----------------------------------------------------------------------------
// Assignment operators
//
// See also lang_list.joe, lang_map.joe, for indexed references.

function testAssignment() {
    var a = 1;
    var b;
    var c;
    c = b = a;
    assertEQ(a, 1);
    assertEQ(b, 1);
    assertEQ(c, 1);
}

function testPlusEquals_var() {
    var x = 5;
    var s = "abc";
    assertEQ(x += 7, 12);
    assertEQ(x, 12);
    assertEQ(s += "def", "abcdef");
    assertEQ(s, "abcdef");
    assertEQ(x += "abc", "12abc");

    var y = 5;
    function bad1() { y += #abc; }
    assertError(bad1,
        "The '+' operator expects two Numbers or at least one String.");
}

function testPlusEquals_property() {
    var thing = Thing();
    thing.x = 5;
    thing.s = "abc";
    assertEQ(thing.x += 7, 12);
    assertEQ(thing.x, 12);
    assertEQ(thing.s += "def", "abcdef");
    assertEQ(thing.s, "abcdef");
    assertEQ(thing.x += "abc", "12abc");

    thing.y = 5;
    function bad1() { thing.y += #abc; }
    assertError(bad1,
        "The '+' operator expects two Numbers or at least one String.");
}

function testMinusEquals_var() {
    var x = 5;
    var s = "abc";
    assertEQ(x -= 7, -2);
    assertEQ(x, -2);

    function bad1() { x -= "abc"; }
    function bad2() { s -= 5; }

    assertError(bad1,
        "The '-' operator expects two numeric operands.");
    assertError(bad2,
        "The '-' operator expects two numeric operands.");
}

function testMinusEquals_property() {
    var thing = Thing();
    thing.x = 5;
    thing.s = "abc";
    assertEQ(thing.x -= 7, -2);
    assertEQ(thing.x, -2);

    function bad1() { thing.x -= "abc"; }
    function bad2() { thing.s -= 5; }

    assertError(bad1,
        "The '-' operator expects two numeric operands.");
    assertError(bad2,
        "The '-' operator expects two numeric operands.");
}

function testStarEquals_var() {
    var x = 5;
    var s = "abc";
    assertEQ(x *= 7, 35);
    assertEQ(x, 35);

    function bad1() { x *= "abc"; }
    function bad2() { s *= 5; }

    assertError(bad1,
        "The '*' operator expects two numeric operands.");
    assertError(bad2,
        "The '*' operator expects two numeric operands.");
}

function testStarEquals_property() {
    var thing = Thing();
    thing.x = 5;
    thing.s = "abc";
    assertEQ(thing.x *= 7, 35);
    assertEQ(thing.x, 35);

    function bad1() { thing.x *= "abc"; }
    function bad2() { thing.s *= 5; }

    assertError(bad1,
        "The '*' operator expects two numeric operands.");
    assertError(bad2,
        "The '*' operator expects two numeric operands.");
}

function testSlashEquals_var() {
    var x = 50;
    var s = "abc";
    assertEQ(x /= 5, 10);
    assertEQ(x, 10);

    function bad1() { x /= "abc"; }
    function bad2() { s /= 5; }

    assertError(bad1,
        "The '/' operator expects two numeric operands.");
    assertError(bad2,
        "The '/' operator expects two numeric operands.");
}

function testSlashEquals_property() {
    var thing = Thing();
    thing.x = 50;
    thing.s = "abc";
    assertEQ(thing.x /= 5, 10);
    assertEQ(thing.x, 10);

    function bad1() { thing.x /= "abc"; }
    function bad2() { thing.s /= 5; }

    assertError(bad1,
        "The '/' operator expects two numeric operands.");
    assertError(bad2,
        "The '/' operator expects two numeric operands.");
}

//-----------------------------------------------------------------------------
// ++, --
//
// See also lang_list.joe, lang_map.joe, for indexed references.

function testPlusPlus_pre_var() {
    var x = 0;
    assertEQ(++x, 1);
    assertEQ(x, 1);
}

function testPlusPlus_pre_prop() {
    var t = Thing();
    t.x = 0;
    assertEQ(++t.x, 1);
    assertEQ(t.x, 1);
}

function testPlusPlus_post_var() {
    var x = 0;
    assertEQ(x++, 0);
    assertEQ(x, 1);
}

function testPlusPlus_post_prop() {
    var t = Thing();
    t.x = 0;
    assertEQ(t.x++, 0);
    assertEQ(t.x, 1);
}

function testPlusPlus_nonNumber() {
    var x = "abc";
    assertError(\-> ++x, "Target of '++' must contain a number.");
    assertError(\-> x++, "Target of '++' must contain a number.");
}

function testMinusMinus_pre_var() {
    var x = 0;
    assertEQ(--x, -1);
    assertEQ(x, -1);
}

function testMinusMinus_pre_prop() {
    var t = Thing();
    t.x = 0;
    assertEQ(--t.x, -1);
    assertEQ(t.x, -1);
}

function testMinusMinus_post_var() {
    var x = 0;
    assertEQ(x--, 0);
    assertEQ(x, -1);
}

function testMinusMinus_post_prop() {
    var t = Thing();
    t.x = 0;
    assertEQ(t.x--, 0);
    assertEQ(t.x, -1);
}

function testMinusMinus_nonNumber() {
    var x = "abc";
    assertError(\-> ++x, "Target of '++' must contain a number.");
    assertError(\-> x++, "Target of '++' must contain a number.");
}


//-----------------------------------------------------------------------------
// Ternary Operator

function testTernary() {
    assertEQ(true ? "a" : "b", "a");
    assertEQ(false ? "a" : "b", "b");
}

//-----------------------------------------------------------------------------
// in/ni Operators

function testIN() {
    var list = [#a, #b, #c];
    assertT(#a in list);
    assertF(#d in list);

    function bad() { return #a in #a; }
    assertError(bad, "Expected iterable, got: Keyword '#a'.");
}

function testNI() {
    var list = [#a, #b, #c];
    assertF(#a ni list);
    assertT(#d ni list);

    function bad() { return #a ni #a; }
    assertError(bad, "Expected iterable, got: Keyword '#a'.");
}

//-----------------------------------------------------------------------------
// ~ Operator

// See lang_matching.joe for pattern syntax tests using `~`

function testMatchOp_simple() {
   var list = [1, 2];
   assertT(list ~ [_, _]);
   assertF(list ~ [_, _, _]);
}

function testMatchOp_bindOnSuccess() {
   var list = [1, 2];
   assertT(list ~ [a, b]);
   assertEQ(a, 1);
   assertEQ(b, 2);
}

function testMatchOp_bindWithAnd() {
   var list = [1, 2];
   assertF(list ~ [a, b] && a > b);
   assertEQ(a, 1);
   assertEQ(b, 2);
}

function testMatchOp_declareOnFailure() {
   var list = [1, 2, 3];
   assertF(list ~ [a, b]);
   assertEQ(a, null);
   assertEQ(b, null);
}

// Verify that having working values on the stack
// doesn't break ~'s binding variables
function testMatchOp_withWorkingStack() {
   var list = [1, 2];
   var value = "(" + (list ~ [a, b]) + ")";
   assertEQ(value, "(true)");
   assertEQ(a, 1);
   assertEQ(b, 2);
}

//-----------------------------------------------------------------------------
// Helpers

class Thing {}
