// Tests for the `class` declaration and class behavior.
//
// Language tests should confine themselves to the basic test API.

//-----------------------------------------------------------------------------
// Declaration and Creation

// Can declare a class
function testDeclare() {
    class Thing {}
    assertEQ(Joe.typeOf(Thing), Type);
}

// Can create instances
function testCreate() {
    class Thing {}
    var thing = Thing();
    assertEQ(Joe.typeOf(thing), Thing);
}

//-----------------------------------------------------------------------------
// Fields

// Scripts can directly set and get an instance's fields.
function testSetGetFields() {
    class Thing {}
    var thing = Thing();
    thing.name = "George";
    thing.color = #ginger;
    assertEQ(thing.name, "George");
    assertEQ(thing.color, #ginger);
}

//-----------------------------------------------------------------------------
// Methods

// Can declare and call methods.
function testDeclareMethod() {
    class Thing {
        method info() { return "I'm a Thing!"; }
    }
    assertEQ(Thing().info(), "I'm a Thing!");
}

// Method arity is checked.
function testMethod_tooFewArgs() {
    class Thing {
        method twoArgs(name, value) { }
    }

    function bad() { Thing().twoArgs(#a); }
    assertError(bad, "Wrong number of arguments, expected: twoArgs(name, value).");
}

// Method arity is checked.
function testMethod_tooManyArgs() {
    class Thing {
        method twoArgs(name, value) { }
    }

    function bad() { Thing().twoArgs(#a, #b, #c); }
    assertError(bad, "Wrong number of arguments, expected: twoArgs(name, value).");
}

// Varargs method
function testMethod_varargs_good() {
    class Thing {
        method varArgs(first, args) {
            return first + "," + args;
        }
    }
    var thing = Thing();

    assertEQ(thing.varArgs(#a), "#a,[]");
    assertEQ(thing.varArgs(#a,#b), "#a,[#b]");
    assertEQ(thing.varArgs(#a,#b,#c), "#a,[#b, #c]");

    function bad() { thing.varArgs(); }
    assertError(bad,
        "Wrong number of arguments, expected: varArgs(first, args).");
}

// Methods can capture enclosing scope.
function testMethodsCaptureScope() {
    var greeting = #howdy;

    class WithStatics {
        method howdy() {
            return greeting;
        }
    }

    assertEQ(WithStatics().howdy(), #howdy);
}

//-----------------------------------------------------------------------------
// Initializer

// The initializer is called on creation, if defined.
function testInitializer() {
    class Thing {
        method init(name, color) {
            this.name = name;
            this.color = color;
        }
    }

    var thing = Thing("Fred", #green);
    assertEQ(thing.name, "Fred");
    assertEQ(thing.color, #green);
}

//-----------------------------------------------------------------------------
// toString()

// Default toString()
function testToString_default() {
    class Thing {}
    var thing = Thing();
    assertT(thing.toString().startsWith("<Thing"));
    assertEQ(Joe.stringify(thing), thing.toString());
}

// Custom toString()
function testToString_custom() {
    class Thing {
        method toString() { return "I'm a Thing!"; }
    }
    var thing = Thing();
    assertEQ(thing.toString(), "I'm a Thing!");
    assertEQ(Joe.stringify(thing), thing.toString());
}

//-----------------------------------------------------------------------------
// Static Methods

// A class can define static methods, which can then be called.
function testDeclareStaticMethod() {
    class WithStatics {
        static method greeting() {
            return #howdy;
        }
    }

    assertEQ(WithStatics.greeting(), #howdy);
}

// Static Methods can call each other.
function testStaticMethods() {
    class WithStatics {
        static method greeting() {
            return #howdy;
        }
        static method howdy() {
            return WithStatics.greeting();
        }
    }

    assertEQ(WithStatics.howdy(), #howdy);
}

// Static methods can capture enclosing scope.
function testStaticMethodsCaptureScope() {
    var greeting = #howdy;

    class WithStatics {
        static method howdy() {
            return greeting;
        }
    }

    assertEQ(WithStatics.howdy(), #howdy);
}

//-----------------------------------------------------------------------------
// Static Fields

// Script can set and get static class fields
function testStaticFields() {
    class Thing {}
    Thing.greeting = #howdy;

    assertEQ(Thing.greeting, #howdy);
}

// Methods can use static class fields
function testStaticFields_instanceMethods() {
    class Thing {
        method howdy() { return Thing.greeting; }
    }
    Thing.greeting = #howdy;

    assertEQ(Thing().howdy(), #howdy);
}

// Static methods can use static class fields
function testStaticFields_staticMethods() {
    class Thing {
        static method howdy() { return Thing.greeting; }
    }
    Thing.greeting = #howdy;

    assertEQ(Thing.howdy(), #howdy);
}

//-----------------------------------------------------------------------------
// Static Initializer

// The static initializer can initialize static fields
function testStaticInitializer_initVars() {
    class Thing {
        static {
            Thing.greeting = #howdy;
        }
    }

    assertEQ(Thing.greeting, #howdy);
}

// The static initializer can call static methods
function testStaticInitializer_initCallsStatics() {
    class Thing {
        static {
            Thing.greeting = Thing.defaultGreeting();
        }
        static method defaultGreeting() { return #howdy; }
    }

    assertEQ(Thing.greeting, #howdy);
}

// The static initializer can create instances
function testStaticInitializer_initCallsStatics() {
    class Thing {
        static {
            Thing.instance = Thing();
        }
    }

    assertEQ(Joe.typeOf(Thing.instance), Thing);
}

// A class can have multiple static initializers
function testStaticInitializer_multiple() {
    // The methods are added just to show separation between the
    // compiled initializer blocks.
    class Thing {
        static { Thing.a = 1; }
        method a() { return Thing.a; }
        static { Thing.b = 2; }
        method b() { return Thing.b; }
    }

    assertEQ(Thing.a, 1);
    assertEQ(Thing.b, 2);

    var thing = Thing();
    assertEQ(thing.a(), 1);
    assertEQ(thing.b(), 2);
}

//-----------------------------------------------------------------------------
// Subclasses

// A class can extend a superclass, and use its methods.
function testSubclass_callParentMethod() {
    class Parent {
        method parent() { return #parent; }
    }

    class Child extends Parent {
        method child() { return #child; }
    }

    var kid = Child();
    assertEQ(kid.parent(), #parent);
    assertEQ(kid.child(), #child);
}

// A subclass can override a superclass method
function testSubclass_overrideParentMethod() {
    class Parent {
        method parent() { return #parent; }
    }

    class Child extends Parent {
        method parent() { return #child; }
    }

    var kid = Child();
    assertEQ(kid.parent(), #child);
}

// A subclass will make use of the parent's init() if it doesn't define one
function testSubclass_parentInitializer() {
    class Parent {
        method init() {
            this.name = "Parent";
        }
    }

    class Child extends Parent {
        method getName() { return this.name; }
    }

    var kid = Child();
    assertEQ(kid.getName(), "Parent");
}

// A subclass will make use of the parent's init() if it doesn't define one.
// A subclass can call a superclass method using `super.`
function testSubclass_callSuper() {
    class Parent {
        method getName() { return #parent; }
    }

    class Child extends Parent {
        method getName() { return super.getName(); }
    }
    var kid = Child();
    assertEQ(kid.getName(), #parent);
}

//-----------------------------------------------------------------------------
// `.` operator

// `.` can be used instead of `this.`
function testCanUseAt() {
    class Thing {
        method init(name, color) {
            .name = name;
            .color = color;
        }

        method info() {
            return "name='" + .name + "' color='" + .color + "'";
        }
    }
    var thing = Thing("Fred", "red");
    assertEQ(thing.info(), "name='Fred' color='red'");
}

//-------------------------------------------------------------------------
// Nested Scopes

// `this.` is available in functions nested in methods
function testThisInNestedFunction() {
    class Nest {
        method init() { this.name = "Howard"; }
        method whoAmI() {
            function getName() {
                return this.name;
            }
            return getName();
        }
    }

    assertEQ(Nest().whoAmI(), "Howard");
}

// `.` is available in functions nested in methods
function testAtInNestedFunction() {
    class Nest {
        method init() { .name = "Howard"; }
        method whoAmI() {
            function getName() {
                return .name;
            }
            return getName();
        }
    }

    assertEQ(Nest().whoAmI(), "Howard");
}

// `super` is available in functions nested in methods
function testSuperInNestedFunction() {
    class Parent {
        method name() { return "Howard"; }
    }
    class Child extends Parent {
        method name() {
            function getName() {
                return "*" + super.name() + "*";
            }
            return getName();
        }
    }

    assertEQ(Child().name(), "*Howard*");
}


